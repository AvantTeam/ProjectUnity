sourceSets.main.java.srcDirs = ['src/']

dependencies{
    compileOnly mindustry(':core')
    compileOnly arc(':arc-core')

    api project(':factions:vanilla')
    api project(':factions:monolith')
}

import arc.files.*
import arc.struct.*
import arc.util.*

import java.util.regex.*

task list(dependsOn: [jar, configurations.runtimeClasspath]){
    doFirst{
        def anon = Pattern.compile('\\$\\d+')

        Seq<String> classes = new Seq<>(), packages = new Seq<>()
        def procFile = { def self, String pack, Fi dir ->
            for(Fi child : dir.list()){
                if(child.isDirectory()){
                    def name = child.name()
                    if(!pack.startsWith('unity') && name != 'unity') continue

                    def packName = pack.empty ? name : "$pack.$name"

                    packages.add(packName)
                    self(self, packName, child)
                }else{
                    def name = child.nameWithoutExtension()
                    if(child.extEquals('class') && !anon.matcher(name).find()){
                        classes.add("$pack.$name")
                    }
                }
            }
        }

        (configurations.runtimeClasspath.files + jar.archiveFile.get().asFile).forEach{
            procFile(procFile, '', new ZipFi(new Fi(it)))
        }

        classes.distinct()
        packages.distinct()

        def output = file("$assetsDir/meta/classes.out")
        output.parentFile.mkdirs()

        output.text = 'Packages:\n'
        for(def p : packages) output.text += "$p\n"

        output.text += "Classes:\n"
        for(def c : classes) output.text += "$c\n"

        println "Successfully listed $packages.size packages and $classes.size classes."
    }
}

task deploy(type: Jar, dependsOn: [list, configurations.runtimeClasspath]){
    mustRunAfter list

    outputs.upToDateWhen{ false }
    if(!spritesDir.exists() || taskNames.contains('tools:proc') || taskNames.contains('proc')){
        dependsOn ':tools:proc'
        mustRunAfter ':tools:proc'

        if(taskNames.contains('mod:deploy') || taskNames.contains('deploy')) println 'Sprites folder not found; automatically generating sprites.'
    }

    archiveFileName = "${modName}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from configurations.runtimeClasspath.collect{ it.isDirectory() ? it : zipTree(it) }
    from files(assetsDir){ exclude 'sprites/vanilla/**' }

    from(rootDir){
        include 'mod.json'
        include 'icon.png'
    }

    doFirst{
        println "Deploying ${devBuild ? 'developer' : 'user'} build."

        def file = Fi.get("$rootDir/mod.json")
        def str = file.readString('UTF-8')
        def matcher = Pattern.compile('"version": "(.*)"').matcher(str)
        if(matcher.find()){
            def start = matcher.start(1), end = matcher.end(1)
            def prev = str.substring(start, end)
            if(prev != modVersion) println "Bumped `mod.json` versioning from $prev to $modVersion."

            file.writeString("${str.substring(0, start)}$modVersion${str.substring(end)}")
        }
    }
}

task dex(type: Jar){
    archiveFileName = "${modName}.jar"

    final def desktopJar = deploy.archiveFile.get().asFile
    final def dexJar = file("$dex.temporaryDir/Dexed.jar")

    if(!desktopJar.exists() || (taskNames.contains('mod:deploy') || taskNames.contains('deploy'))) dependsOn deploy
    doFirst{
        println 'Dexifying...'
        def command = "d8 --min-api $sdkAPI --output $dexJar $desktopJar"

        (configurations.compileClasspath.asList() + configurations.runtimeClasspath.asList()).forEach{
            if(it.exists()) command += " --classpath $it.path"
        }

        command += " --lib ${file("$sdkRoot/platforms/android-$sdkVersion/android.jar")}"

        if(OS.isWindows) command = 'cmd /c ' + command
        command.execute(null, new File("$buildDir/libs")).waitForProcessOutput(System.out, System.err)
    }

    from zipTree(desktopJar)
    from zipTree(dexJar)
}

tasks.withType(Jar){
    if(!devBuild) exclude 'unity/mod/DevBuildImpl*'
}
