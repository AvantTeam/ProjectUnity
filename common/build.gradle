sourceSets.main.java.srcDirs = ['src/', "${compileJava.temporaryDir}/fetched/"]

ext{
    fetchPackage = 'unity/fetched'
    fetchDir = file("${compileJava.temporaryDir}/fetched/$fetchPackage")
    fetchTemp = file("${compileJava.temporaryDir}/fetch.txt")
    fetchRevision = 0
}

dependencies{
    compileOnly mindustry(':core')
    compileOnly arc(':arc-core')
    compileOnly project(':annotations')

    //annotationProcessor "com.github.Anuken:jabel:$jabelVersion"
    kapt project(':annotations')
}

import arc.files.*
import arc.struct.*
import arc.util.*
import arc.util.serialization.*

static String processComp(String source, String fetchPackage){
    return source
        .replace('mindustry.entities.comp', fetchPackage)
        .replace('mindustry.annotations.Annotations.*', 'unity.annotations.Annotations.*')
        .replaceAll('@Component\\((base = true|.)+\\)\n*', '@EntityComponent(base = true, vanilla = true)\n')
        .replaceAll('@Component\n*', '@EntityComponent(vanilla = true)\n')
        .replaceAll('@BaseComponent\n*', '@EntityBaseComponent\n')
        .replaceAll('@CallSuper\n*', '')
        .replaceAll('@Final\n*', '')
        .replaceAll('@EntityDef\\(*.*\\)*\n*', '')
}

task procComps{
    doFirst{
        def fetch = fetchPackage.replace('/', '.')

        Fi dir = new Fi(fetchDir)
        for(Fi fi : dir.list()){
            if(!fi.extEquals("java")) continue;
            fi.writeString(processComp(fi.readString()), fetch)
        }
    }
}

task fetchComps{
    doFirst{
        delete{ delete fetchDir }
        fetchDir.mkdir()

        final def fetchPack = fetchPackage.replace('/', '.')
        def amount = 0

        final ObjectSet<UnsafeRunnable> fetches = new ObjectSet<>()
        Http.get("https://api.github.com/repos/Anuken/MindustryJitpack/contents/core/src/mindustry/entities/comp?ref=$mindustryVersion")
            .timeout(0)
            .error({ final t -> throw new RuntimeException(t) })
            .block({ final res ->
                final def list = Jval.read(res.getResultAsString()).asArray()
                synchronized(fetches){ amount = list.size }

                for(final Jval val : list){
                    final def filename = val.get('name').asString()
                    final def fileurl = val.get('download_url').asString()

                    final UnsafeRunnable run = {
                        Http.get(fileurl)
                            .timeout(0)
                            .error({ final t -> throw new RuntimeException(t) })
                            .block({ final comp ->
                                final def fi = Fi.get("$fetchDir/$filename")
                                fi.writeString(processComp(comp.getResultAsString(), fetchPack), false)

                                synchronized(fetches){ amount-- }
                            })
                    }

                    fetches.add(run)
                }
            })

        Seq<Thread> threads = Seq.with(fetches).map({ final UnsafeRunnable fetch -> new Thread({
            try{
                fetch.run()
            }catch(Throwable t){
                Log.err(t);
            }

            synchronized(fetches){ fetches.remove(fetch) }
        }) })

        threads.each(Thread::start)
        while(true){
            if(!fetches.empty){
                Thread.currentThread().yield()
            }else{
                threads.each(Thread::join)
                break
            }
        }

        if(amount != 0) throw new IllegalStateException("Couldn't write all components found: $amount unwritten.")
        fetchTemp.text = "$mindustryVersion/$fetchRevision"
    }
}

tasks.withType(JavaCompile){
    if(!fetchDir.exists() || !fetchTemp.exists()){
        dependsOn fetchComps
    }else{
        String[] content = fetchTemp.text.split('/')
        String ver = content[0].strip()
        String rev = content[1].strip()

        if(ver != "$mindustryVersion" as String || rev != Integer.toString(fetchRevision as int)){
            dependsOn fetchComps
        }
    }
}

tasks.withType(Jar){
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    exclude 'unity/fetched/**'
    exclude 'unity/gensrc/**'
}
