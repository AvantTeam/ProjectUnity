sourceSets.main.java.srcDirs = ['src/', "$buildDir/generated/sources/annotationProcessor/java/main/", "$projectDir/fetched"]

import arc.*
import arc.files.*
import arc.struct.*
import arc.util.*
import arc.util.async.*
import arc.util.serialization.*

import java.util.*

dependencies {
    compileOnly "com.github.Anuken.Arc:arc-core:$mindustryVersion"
    compileOnly "com.github.Anuken.Mindustry:core:$mindustryVersion"

    annotationProcessor "com.github.Anuken:jabel:$jabelVersion"

    compileOnly project(':annotations')
    annotationProcessor project(':annotations')
}

ext {
    assetsDir = new File(rootDir, "main/assets/")

    fetchPackage = 'unity/fetched'
    fetchDir = new File("$projectDir/fetched/$fetchPackage")

    fetchTemp = new Fi("$projectDir/fetch.txt")
    fetchRevision = 1
}

task deploy(type: Jar, dependsOn: configurations.runtimeClasspath) {
    if(!hasSprites()) {
        println 'Sprites folder not found; automatically processing sprites...'
        deploy.dependsOn ":tools:proc"
    }

    archiveFileName = "${modName}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    from files(project.assetsDir)
    from(rootDir) { include 'mod.json' }

    exclude 'unity/fetched/**'
    exclude 'unity/entities/comp/**'
    exclude 'unity/entities/merge/**'
}

task dex(dependsOn: deploy) {
    def jarArtifact = file(tasks.deploy.archiveFile.get())
    def dexedArtifact = new File("$buildDir/libs", 'Dexed.jar')

    doLast { exec {
        workingDir "$buildDir/libs"

        def command = ['d8']
        def files = (
            configurations.compileClasspath.asList() +
            configurations.runtimeClasspath.asList() +
            [new File("${sdkRoot()}/platforms/android-${sdkVersion()}/android.jar")]
        )

        for(def file : files) {
            command += '--classpath'
            command += file.path
        }

        command += ['--min-api', sdkAPI(), '--output', dexedArtifact, jarArtifact]
        if(windows()) {
            commandLine('cmd', '/c', *command)
        } else {
            commandLine(*command)
        }
    }}
}

task deployDex(type: Jar, dependsOn: [deploy, dex]) {
    archiveFileName = "${modName}Dexed.jar"

    def jarArtifact = file(tasks.deploy.archiveFile.get())
    def dexedArtifact = new File("$buildDir/libs", 'Dexed.jar')

    from zipTree(jarArtifact)
    from zipTree(dexedArtifact)

    doLast { delete {
        delete jarArtifact
        delete dexedArtifact
    }}
}

repositories {
    mavenCentral()
    maven { url 'https://www.jitpack.io' }
}

class Fetcher {
    static Seq<String> prints = new Seq<String>()

    String name
    UnsafeRunnable run

    private Throwable error = null

    void execute() {
        Closure<Boolean> exec = { final UnsafeRunnable run ->
            if(name != null) prints.add("---- Trying to fetch '$name'...")
            try {
                run.run()
                error = null
            } catch(Throwable e) {
                if(name != null) prints.add("------ Failed to fetch '$name'. Trying again.")
                error = e
            }

            error != null
        }

        while(exec(run)) continue
    }
}

task fetchComps {
    doFirst {
        delete { delete fetchDir }
        fetchDir.mkdir()

        Core.net = new Net()
        Core.net.setBlock(true)

        final Seq<Fetcher> fetches = new Seq<Fetcher>(Fetcher.class)

        final UnsafeRunnable mainRun = {
        Core.net.httpGet(
        "https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/entities/comp?ref=$mindustryVersion",
        { res ->
            final def list = Jval.read(res.getResultAsString()).asArray()
            Fetcher.prints.add("Found $list.size entity components.")

            for(def val : list) {
                final def filename = val.get('name').asString()
                final def fileurl = val.get('download_url').asString()

                final UnsafeRunnable run = {
                Core.net.httpGet(
                fileurl,
                { comp ->
                    final def content = comp.getResultAsString()
                        .replace('mindustry.entities.comp', "$fetchPackage".replace('/', '.'))
                        .replace('mindustry.annotations.Annotations.*', 'unity.annotations.Annotations.*')
                        .replaceAll('\\@Component\\((base = true|.)+\\)\n*', '@EntityComponent(base = true, write = false)\n')
                        .replaceAll('\\@Component\n*', '@EntityComponent(write = false)\n')
                        .replaceAll('\\@BaseComponent\n*', '@EntityBaseComponent\n')
                        .replaceAll('\\@CallSuper\n*', '')
                        .replaceAll('\\@Final\n*', '')
                        .replaceAll('\\@EntityDef\\(*.*\\)*\n*', '')

                    if(content.isBlank()) throw new IllegalStateException()

                    final def fi = Fi.get("$fetchDir/$filename")
                    fi.writeString(content, false)
                },
                { err -> throw new RuntimeException(err) })}

                fetches.add(new Fetcher(name: filename, run: run))
            }
        },
        { err -> throw new RuntimeException(err) })}

        new Fetcher(run: mainRun).execute()

        fetches.each({ final Fetcher fetch -> Threads.thread({
            fetch.execute()
            synchronized(fetches) {
                fetches.remove(fetch)
                Fetcher.prints.add("-- Wrote '$fetch.name', $fetches.size left." as String)
            }
        }) })

        while(!fetches.isEmpty() || !Fetcher.prints.isEmpty()) {
            Iterator<String> ite = Fetcher.prints.iterator()
            while(ite.hasNext()) {
                println ite.next()
                ite.remove()
            }
        }

        fetchTemp.writeString("$mindustryVersion/$fetchRevision")
        println 'Done writing.'
    }
}

task cleanFetched(type: Delete) {
    delete "$projectDir/fetched"
    delete "$fetchTemp"
}

task sourcesJar(type: Jar, dependsOn: classes) {
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
}

task assetsJar(type: Jar, dependsOn: ":tools:proc") {
    archiveClassifier = 'assets'
    from files(assetsDir)
}

artifacts {
    archives sourcesJar
    archives assetsJar
}

clean {
    finalizedBy cleanFetched
}

compileJava {
    options.compilerArgs += [
        '-processor', 
            'unity.annotations.FactionProcessor,' +
            'unity.annotations.EntityProcessor,' +
            'unity.annotations.LoadProcessor,' +
            'unity.annotations.AssetsProcessor,' +
            'unity.annotations.MergeProcessor'
    ]

    if(!fetchDir.exists() || !fetchTemp.exists()) {
        dependsOn fetchComps
    } else {
        String[] content = fetchTemp.readString().split('/')
        String ver = content[0]
        String rev = content[1]

        if(ver != new String("$mindustryVersion") || rev != Integer.toString(fetchRevision as int)) {
            println 'Temp fetch data mismatch:'
            println "Stored  : { version: $ver, revision: $rev }"
            println "Required: { version: $mindustryVersion, revision: $fetchRevision }"

            dependsOn fetchComps
        }
    }
}

jar {
    exclude 'unity/fetched/**'
    exclude 'unity/entities/comp/**'
    exclude 'unity/entities/merge/**'
}
