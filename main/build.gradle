sourceSets.main {
    java.srcDirs = [
        'src/',
        "$projectDir/fetched",
        "$buildDir/generated/sources/annotationProcessor/java/main/"
    ]
}

sourceCompatibility = 16
targetCompatibility = 8

dependencies {
    compileOnly "com.github.Anuken.Mindustry:core:$mindustryVersion"

    compileOnly project(':annotations')
    annotationProcessor project(':annotations')

    annotationProcessor "com.github.bsideup.jabel:jabel-javac-plugin:$jabelVersion"
}

ext {
    assetsDir = new File(rootDir, "main/assets/")

    fetchPackage = 'unity/fetched'
    fetchDir = new File("$projectDir/fetched/$fetchPackage")

    fetchTemp = new File("$projectDir/fetch.txt")
    fetchRevision = 1
}

import arc.*
import arc.files.*
import arc.func.*
import arc.struct.*
import arc.util.*
import arc.util.serialization.*

import java.util.concurrent.*

task deploy(type: Jar, dependsOn: configurations.runtimeClasspath) {
    archiveFileName.set "${modName}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    from files(project.assetsDir)
    from(rootDir) { include 'mod.json' }

    doFirst {
        println "Deploying ${devBuild ? 'dev' : 'user'} build."
    }
}

task deployDex(type: Jar, dependsOn: deploy) {
    archiveFileName.set "${modName}.jar"

    final def desktopJar = deploy.archiveFile.get()
    final def dexJar = new File(deployDex.getTemporaryDir(), 'Dexed.jar')

    doFirst {
        println 'Dexifying...'
        exec {
            def command = ['d8', '--min-api', sdkAPI, '--output', dexJar, desktopJar]
            final File[] files =
                configurations.compileClasspath.asList() +
                configurations.runtimeClasspath.asList() +
                file("$sdkRoot/platforms/android-$sdkVersion/android.jar")

            for(def file : files) {
                assert file.exists()
                command += ['--classpath', file.path]
            }

            if(System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')) {
                command = ['cmd', '/c'] + command
            }

            commandLine(*command)
        }
    }

    from zipTree(desktopJar)
    from zipTree(dexJar)
}

class Fetcher {
    UnsafeRunnable run

    private volatile Throwable error = null

    @SuppressWarnings('all')
    void execute() {
        Boolf<UnsafeRunnable> exec = { final UnsafeRunnable run ->
            try {
                run.run()
                error = null
            } catch(Throwable e) {
                Log.err(e)
                error = e
            }

            error != null
        }

        //while(exec.get(run)) {}
        println exec.get(run)
    }
}

task fetchComps {
    doFirst {
        delete { delete fetchDir }
        fetchDir.mkdir()

        final CopyOnWriteArrayList<Fetcher> fetches = new CopyOnWriteArrayList<>()

        UnsafeRunnable mainRun = {
        Http.get("https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/entities/comp?ref=$mindustryVersion")
            .timeout(0)
            .block({ final res ->
                final def list = Jval.read(res.getResultAsString()).asArray()
                println "Found $list.size entity components."

                for(final Jval val : list) {
                    final def filename = val.get('name').asString()
                    final def fileurl = val.get('download_url').asString()

                    final UnsafeRunnable run = {
                    Http.get(fileurl)
                        .timeout(0)
                        .block({ final comp ->
                            final def content = comp.getResultAsString()
                                .replace('mindustry.entities.comp', "$fetchPackage".replace('/', '.') as String)
                                .replace('mindustry.annotations.Annotations.*', 'unity.annotations.Annotations.*')
                                .replaceAll('@Component\\((base = true|.)+\\)\n*', '@EntityComponent(base = true, write = false)\n')
                                .replaceAll('@Component\n*', '@EntityComponent(write = false)\n')
                                .replaceAll('@BaseComponent\n*', '@EntityBaseComponent\n')
                                .replaceAll('@CallSuper\n*', '')
                                .replaceAll('@Final\n*', '')
                                .replaceAll('@EntityDef\\(*.*\\)*\n*', '')

                            if(content.isEmpty()) throw new IllegalStateException()

                            final def fi = Fi.get("$fetchDir/$filename")
                            fi.writeString(content, false)
                        })
                        .error({ final t -> throw new RuntimeException(t) })
                    }

                    fetches.add(new Fetcher(run: run))
                }
            })
            .error({ final t -> throw new RuntimeException(t) })
        }

        new Fetcher(run: mainRun).execute()
        final def found = fetches.size()

        Seq<Thread> threads = Seq.with(fetches).map({ final Fetcher fetch -> new Thread({
            fetch.execute()
            synchronized(fetches) {
                fetches.remove(fetch)
            }
        }) })

        threads.each(Thread::start)
        while(!fetches.isEmpty()) Thread.currentThread().yield()

        fetchTemp.text = "$mindustryVersion/$fetchRevision"
        println "Wrote $found entity components."
    }
}

task cleanFetched(type: Delete) {
    delete "$projectDir/fetched"
    delete "$fetchTemp"
}

task assetsJar(type: Jar) {
    archiveClassifier.set('assets')
    from files('assets/')
}

artifacts {
    archives assetsJar
}

tasks.withType(JavaCompile) {
    if(!fetchDir.exists() || !fetchTemp.exists()) {
        dependsOn fetchComps
    } else {
        String[] content = fetchTemp.text.split('/')
        String ver = content[0]
        String rev = content[1]

        if(ver != "$mindustryVersion" as String || rev != Integer.toString(fetchRevision as int)) {
            dependsOn fetchComps
        }
    }

    if(JavaVersion.current() != JavaVersion.VERSION_1_8) {
        options.compilerArgs += ['--release', '8']
    }
}

tasks.withType(Jar) {
    exclude 'unity/fetched/**'
    exclude 'unity/entities/comp/**'
    exclude 'unity/entities/merge/**'
    if(!devBuild) exclude 'unity/mod/DevBuildImpl*'
}
