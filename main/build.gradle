sourceSets.main.java.srcDirs = ["src/", "$buildDir/generated/sources/annotationProcessor/java/main/"]

import arc.*;
import arc.files.*;
import arc.struct.*;
import arc.util.*;
import arc.util.serialization.*;

import java.net.*;
import java.util.concurrent.*;

ext{
    assetsDir = new File(rootDir, "main/assets/")

    fetchPackage = 'mindustry/fetched'
    fetchDir = new File("$buildDir/generated/sources/annotationProcessor/java/main/$fetchPackage/")
}

task deploy(type: Jar, dependsOn: configurations.runtimeClasspath){
    archiveFileName = "${modName}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from{
        configurations.runtimeClasspath.collect{
            it.isDirectory()
            ?   it
            :   zipTree(it)
        }
    }
    from files(project.assetsDir)

    doLast{
        delete{ delete "$buildDir/libs/main-${version}.jar" }
    }
}

task dex{
    dependsOn deploy

    doLast{
        exec{
            workingDir = "$buildDir/libs/"
            def command = ["d8", "--min-api", "15", "--output", "${modName}Dexed.jar", "${modName}Desktop.jar"]

            if(windows()){
                commandLine("cmd", "/c", *command)
            }else{
                commandLine(*command)
            }
        }
    }
}

task deployDex(type: Jar){
    dependsOn deploy, dex

    archiveFileName = "${modName}.jar"

    from{[
        zipTree("$buildDir/libs/${modName}Desktop.jar"),
        zipTree("$buildDir/libs/${modName}Dexed.jar")
    ]}

    doLast{
        delete{
            delete "$buildDir/libs/${modName}Desktop.jar"
            delete "$buildDir/libs/${modName}Dexed.jar"
        }
    }
}

if(!hasSprites()){
    println "Sprites folder not found; automatically processing sprites..."
    deploy.dependsOn ":tools:proc"
}

repositories{
    mavenCentral()
    maven{url "https://www.jitpack.io"}
}

task fetchComps {
    doFirst {
        delete { delete fetchDir }
        fetchDir.mkdir()

        Core.net = new Net()
        Core.net.setBlock(true)
        println 'Fetching mindustry entity comps...'

        int[] done = [Integer.MAX_VALUE]

        Core.net.http(
        new Net.HttpRequest()
            .timeout(0)
            .header('Accept', 'application/json')
            .method(Net.HttpMethod.GET)
            .url("https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/entities/comp?ref=$mindustryVersion"),

        { res -> try {
            def list = Jval.read(res.getResultAsString()).asArray()
            done[0] = list.size

            println "Found all ${done[0]} mindustry entity comps."

            for(def val : list) {
                def filename = val.get('name').asString()
                def fileurl = val.get('download_url').asString()

                Core.net.http(
                new Net.HttpRequest()
                    .timeout(0)
                    .header('Accept', 'application/json')
                    .method(Net.HttpMethod.GET)
                    .url(fileurl),

                { comp -> try {
                    def content = comp.getResultAsString()
                        .replace('mindustry.entities.comp', "$fetchPackage".replace('/', '.'))
                        .replace('mindustry.annotations.Annotations.*', 'unity.annotations.Annotations.*')

                    def fi = new Fi("$fetchDir/$filename")
                    fi.writeString(content)

                    done[0]--
                    println "Wrote '$filename': ${done[0]} left."
                } catch(Throwable t) {
                    throw new RuntimeException(t)
                }},

                { err -> throw err }
                )
            }
        } catch(Throwable t) {
            throw new RuntimeException(t)
        }},

        { err -> throw err }
        )

        println 'Done writing.'
    }
}

dependencies{
    compileJava.dependsOn fetchComps

    compileOnly "com.github.Anuken.Arc:arc-core:$mindustryVersion"
    compileOnly "com.github.Anuken.Mindustry:core:$mindustryVersion"

    implementation "com.github.younggam:multi-lib:$multilibVersion"
    annotationProcessor "com.github.Anuken:jabel:$jabelVersion"

    compileOnly project(":annotations")
    annotationProcessor project(":annotations")

    compileJava.options.compilerArgs.addAll([
        "-processor", 
            "unity.annotations.FactionProcessor," +
            "unity.annotations.EntityProcessor," +
            "unity.annotations.LoadProcessor," +
            "unity.annotations.AssetsProcessor," +
            "unity.annotations.MergeProcessor"
    ])
}
